STL的空间配置器有两个，一个是allocate 只是对operaotr new做一层薄薄的包装，设计
 更为精妙，效率更高的是alloc,这也是所有容器默认的空间配置器。
 
 平常的new表达式是 分配空间，调用构造合在一起。在alloc中把它们分开了
 allocate()分配空间 construct创造对象
 destory()销毁对象 deallocate()回收空间
 
 allocate()内部使用placement new 创建对象
 construct()有根据类型的不同有不同的实现方式
 
 考虑的问题:
 1.多线程状态
 2.内存不足的措施
 3.堆空间碎片化问题

 一级配置器，直接使用malloc/free，二级配置器采用16个链表+内存池的策略。

 当配置区块超过128byte时，视为足够大，便调用一级配置器，当小于128时使用二级配置器.

 一二级配置器的使用取决于_USE_MALLOC是否定义

 无论是一级还是二级alloc 都需要封装一层simple_alloc使其能符合STL的标准。

 一级配置器模拟了c++ new handler机制用于处理内存不足的情况，所谓c++ new handle机制就是
 在内存不足抛出异常前调用一个指定的函数，一旦malloc失败，就得调用oom_malloc，其中有循环不断
 调用内存不足处理例程，期待能有足够的内存完成任务，但如果没有设定处理例程，那么就会抛出异常

 二级配置器，有16个档位，每个档位+8递增。每个节点数据是union类型，既可以是指针指向下一位置，
 也可以是指针指向内存块。一物两用，不会为了维护链表的指针造成一种浪费。

 allocate函数，如果比128大就调用一级配置器，如果比128小，看这个档位的链表中是否有内存块，如果
 有空闲的就返回，如果没有使用refill函数重新分配。
 deallocate函数：如果比128大就....如果小，把它回收到链表中，其实就是头插法。

 refill函数通过chunk_alloc向内存池中取的一大块内存(默认20*size)，并把它分割成档位大小的块，拼接在链表上

内存池由三个指针标识
_start_free
_end_free
heap_size

chunk_alloc函数有三种情况，
如果内存池水量充足，你要多少我都能返回多少

如果内存池水量不足，只能分配大于一块小于n块的内存。

如果内存池一块也没有了，只能从堆空间再申请来扩展内存池（大小是需求量*2+随配置次数越来越大的附加量）
如果堆空间也没有了，只能找找比它大的链表节点是否有空闲，把它释放。
如果没有空闲链表，就只能试试调用一级配置器，看看第一层的oom机制是否有用了

内存处理函数
construct
destory
uninitialized_copy()
uninitialized_fill()
uninitialized_fill_n()
