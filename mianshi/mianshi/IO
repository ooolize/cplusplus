阻塞i/o 没有数据会卡主/断开返回0/正常返回正数
 
 不严谨的说
 同步/异步指的是当i/o操作来临时，进程是否会等待。
 阻塞/非阻塞指的是等待操作是挂起进程还是立刻返回。
  
 当然异步/同步关注的是消息通信机制，
同步需要自己取数据，而异步的存取工作是通过内核完成的。
 
 举一个例子：
 书店买书        



3.i/o复用
int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);

返回值
三个fd_set分别监视文件描述符的读写异常变化，
如果有select会返回一个大于0的值。
如果没有则在timeout的时间后select返回0，
若发生错误返回负值

timeval值
timeval 可以是NULL表示一直阻塞（没有就绪的描述符就）=0就是不阻塞 n就是阻塞n个时间


select ---定义读写集合---》FD_ZERO--->select--->FD_ISSET     等待描述符就绪需要多少时间 
epoll与select
select的缺点---监控的文件描述符数量有限/每次都需要遍历集合取出相应的，时间复杂度是O(n)/每次select前都需要将集合从用户态向内核态拷贝一次
epoll的解决方法---内核中维护一个红黑树和就绪链表，注册(epoll_ctl)监控对象时都放到红黑树中,一旦有I/O输入，就放在就绪链表里，每次epoll_wait取就从就绪队列里取就行
epoll的优点---可监控的文件描述符多/每次不用遍历集合，直接从就绪队列里拿就好/每次不需要从新设置集合，需要监控的直接放在红黑树里即可

ET和LT
ET是高速模式，LT是默认模式。ET必须保证使用非阻塞编程，一次把缓冲区读取完毕。否则会影响到下次读取
，对于socket_fd我们不应设置为ET的，否则如果多个请求来，只会处理accept一个。


