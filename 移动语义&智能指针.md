### mellocfree delete/new 表达式
### 移动语义与右值
> 右值是临时变量，它不出现在内存中，不能够取地址。
常见的右值：匿名变量(a+b)，字面值常量，i++,局部变量

```c++
vector<String> v;
v.push_back("hello");
```
如果不使用移动语义，那么它调用拷贝赋值运算符。中间会在push_back()方法内部产生一个额外的字符串。我们想直接把这个临时变量使用起来，这就需要使用移动语义。

在c++11之前，使用const 引用来处理，它并不区分左值右值，统统都使用拷贝操作

c++11使用&&绑定右值，进行移动操作。
```c++
String(String &&rhs)//String s("hello");
:_ptr(rhs._ptr)
{
    rhs._ptr=nulltpr;
}

String& operator=(String &&rhs)//s1="world";
{
    if(this!=&rhs){           //自移动
        if(_pstr)             //释放左操作数
            delete [] _pstr;  
        _pstr=rhs._pstr;      //浅拷贝
        rhs._pstr=nullptr;    //移动
    }
}
```
+ 在移动拷贝内部，rhs有名字是一个左值。
+ 需要在编译时添加编译选项以显示移动调用 -fno-elide-constructors
+ 当定义移动语义后，右值就会调用这个版本，否则会调用拷贝版本
+ 移动语义不需要加const 因为它语义就是改变
### std::move
> 将左值变为右值。
unique_ptr<int>q1=std::move(q2);

### 资源管理
c++使用智能指针进行资源管理，智能指针的基本思想是封装对象，在析构函数中进行资源回收，这样对象消亡后会自动回收它的资源。

#### unique_ptr 
  + 初始化 unique_ptr<int> up(new int(1));
  + 放弃托管的对象 up.release();
  + 重新托管对象 up.reset();
  + 得到托管对象 up.get();
  
unique指针是拥有所绑定的对象的。是对象语义，它没有拷贝函数。

一般用堆空间的都可以使用unique指针
```c++
#include <iostream>
#include <memory>

using std::cout;
using std::endl;
using std::shared_ptr;
using std::unique_ptr;

int main()
{
    unique_ptr<int> up(new int(1));
    unique_ptr<int> up1(new int(2));
    
    cout<<"*up = "<<*up<<endl;
    cout<<"*up1 ="<<*up1<<endl;

    /* up=up1; 没有拷贝语义 */
    
    up1=std::move(up);
    /* cout<<"*up = "<<*up<<endl;up已经被移动 */
    cout<<"*up1 ="<<*up1<<endl;
    
    up.reset(new int(3));
    up1.release();
    cout<<"*up = "<<*up<<endl;
    cout<<"*up1 ="<<*up1<<endl;
    
    vector<unque_ptr<int>> vup;
    //vup.push_back(up);error
    vup.push_back(unique_ptr<int>(up1))//yes
    vup.push_back(unique_ptr<int>(std::move(up1))//yes
    
    return 0;
}
```

+ 自定义删除器:
```c++
class deFILE{
public:
  void operator()(FILE*fp){
      if(fp){
          fclose(fp);
      }
  }
}
int main(){
  unique_ptr<FILE*,deFILE> up(fopen("text.txt","a+"));
  string s="aabb";
  fwrite(s,1,s.size(),up.get());
  
}
```
+ 隐藏的移动语义。

因为返回的是临时变量，当getValue结束时，返回的是一个右值。调用的不是拷贝而是移动赋值函数。

```c++
unique_ptr<int> getValue(){
    unique_ptr<int> up(new int(2));
    return up;
}
int main(){
  unique_ptr<int> up(new int(1));
  up=getValue();
}
```


#### shared_ptr
  + 具有移动语义和拷贝语义
  + use_count()返回引用计数
  + 没有release()成员
  
